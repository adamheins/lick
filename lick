#!/usr/bin/env python

from __future__ import print_function

import argparse
import json
import os
import re
import requests

from colorama import Fore, Style
from datetime import date

LICENSES = ['APACHE', 'MIT', 'BSD-2-CLAUSE', 'BSD-3-CLAUSE']
LICENSE_ROOT_URL = 'https://raw.githubusercontent.com/adamheins/lick/master/licenses'

def load_properties(req_props):
    """ Load the values of the required properties to fill out the license. """
    properties = {}

    # First, check for a file pointed to $LICK_PROPERTIES_FILE_PATH.
    # If that does not exist, attempt to load the default config at
    # ~/.lick.json.
    fp = os.environ.get('LICK_PROPERTIES_FILE_PATH')
    print(Fore.RED, end='')
    if fp is not None:
        try:
            with open(fp) as f:
                properties.update(json.load(f))
        except IOError:
            print('  warning: file pointed to by $LICK_PROPERTIES_FILE_PATH'
                  ' could not be opened')
        except ValueError:
            print("  warning: lick properties file at '{}' contains malformed"
                  " JSON".format(fp))
    else:
        default_file_path = os.path.expanduser('~/.lick.json')
        try:
            with open(default_file_path) as f:
                properties.update(json.load(f))
        except IOError:
            pass
        except ValueError:
            print("  warning: lick properties file at '{}' contains malformed"
                  " JSON".format(default_file_path))
    print(Fore.RESET, end='')

    req_props = set(req_props) - set(properties.keys())

    # Use the current error if is hasn't already been defined.
    if 'year' in req_props:
        properties['year'] = str(date.today().year)
        req_props.remove('year')

    # Get the rest of the required properties from terminal input.
    if len(req_props) > 0:
        print('Enter properties:')
    for prop in req_props:
        properties[prop] = raw_input('  {}: '.format(prop))
    return properties

def parse_required_properties(text):
    """ Parse which properties are required to fill out the license. """
    return set(re.findall(r'<(\S+)>', text))

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('type', nargs='?', help='Type of license to use.')
    parser.add_argument('-o', '--output', help='File to which to output the'
                        ' license.')
    parser.add_argument('-l', '--list', help='List all available licenses.',
                        action='store_true')
    args = parser.parse_args()

    # Check if the license type is supported.
    license = args.type.upper()
    if license not in LICENSES:
        print(Fore.RED, end='')
        print("error: unsupported license '{}'".format(args.type))
        print(Fore.RESET, end='')
        exit(1)

    # GET request for the license text.
    print('Licking {}...'.format(license))
    url = '/'.join([LICENSE_ROOT_URL, license])
    req = requests.get(url)
    if req.status_code != 200:
        print(Fore.RED, end='')
        print('  error: {} {}'.format(req.status_code, req.text))
        print(Fore.RESET, end='')
        return

    # Load required fields.
    text = req.text
    req_props = parse_required_properties(text)
    properties = load_properties(req_props)
    for prop in properties: # TODO rename to fields
        text = text.replace('<' + prop + '>', properties[prop])

    # Write the license file.
    license_file_path = args.output if args.output else 'LICENSE'
    with open(license_file_path, 'w') as license:
        license.write(text)
    print("License '{}' written to '{}'".format(args.type, license_file_path))

if __name__ == '__main__':
    main()
